package fr.baretto.ollamassist.chat.rag;import com.intellij.notification.Notification;import com.intellij.notification.NotificationType;import com.intellij.notification.Notifications;import com.intellij.openapi.Disposable;import com.intellij.openapi.application.ApplicationManager;import com.intellij.openapi.project.Project;import com.intellij.openapi.vfs.VirtualFile;import com.intellij.openapi.vfs.VirtualFileEvent;import com.intellij.openapi.vfs.VirtualFileListener;import com.intellij.openapi.vfs.VirtualFileManager;import com.intellij.util.messages.MessageBusConnection;import dev.langchain4j.data.segment.TextSegment;import fr.baretto.ollamassist.events.StoreNotifier;import lombok.extern.slf4j.Slf4j;import org.jetbrains.annotations.NotNull;import java.util.Collections;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.TimeUnit;@Slf4jpublic class ProjectFileListener implements Disposable, StoreNotifier {    private final IndexRegistry indexationRegistry;    private final Project project;    private final LuceneEmbeddingStore<TextSegment> store;    private final DocumentIndexingPipeline documentIndexingPipeline;    private final Set<String> currentModifiedFiles;    private final Debouncer<String> debouncer;    private final VirtualFileListener virtualFileListener;    private final MessageBusConnection connection;    private final FilesUtil filesUtil;    public ProjectFileListener(@NotNull Project project, LuceneEmbeddingStore<TextSegment> store) {        this.project = project;        this.store = store;        this.virtualFileListener = createFileListener();        this.connection = project.getMessageBus().connect();        this.debouncer = new Debouncer<>(1, TimeUnit.MINUTES);        this.currentModifiedFiles = Collections.newSetFromMap(new ConcurrentHashMap<>());        this.filesUtil = project.getService(FilesUtil.class);        this.indexationRegistry = ApplicationManager.getApplication().getService(IndexRegistry.class);        this.documentIndexingPipeline = project.getService(DocumentIndexingPipeline.class);        setupFileWatcher();        subscribeToEvents();    }    private void setupFileWatcher() {        VirtualFileManager.getInstance().addVirtualFileListener(virtualFileListener, this);    }    private VirtualFileListener createFileListener() {        return new VirtualFileListener() {            @Override            public void fileCreated(@NotNull VirtualFileEvent event) {                handleFileCreated(event);            }            @Override            public void contentsChanged(@NotNull VirtualFileEvent event) {                handleContentsChanged(event);            }            @Override            public void fileDeleted(@NotNull VirtualFileEvent event) {                handleFileDeleted(event);            }        };    }    private void subscribeToEvents() {        connection.subscribe(StoreNotifier.TOPIC, this);    }    public void clear() {        store.removeAll();        indexationRegistry.removeProject(project.getName());        load();    }    @Override    public void indexCorrupted() {        indexationRegistry.markAllAsCorrupted();        project.getMessageBus().syncPublisher(Notifications.TOPIC)                .notify(new Notification(                        "index_corrupted",                        "RAG index corrupted",                        "Configuration change detected. Index was corrupted and is now being reindexed.",                        NotificationType.INFORMATION                ));        load();    }    private void handleFileCreated(@NotNull VirtualFileEvent event) {        if (filesUtil.shouldBeIndexed(event.getFile())) {            debouncer.debounce(event.getFile().getName(), () -> {                VirtualFile file = event.getFile();                if (file.getLength() > 0) {                    documentIndexingPipeline.addDocument(file.getPath());                }            });        }    }    private void handleContentsChanged(@NotNull VirtualFileEvent event) {        if (filesUtil.shouldBeIndexed(event.getFile())) {            debouncer.debounce(event.getFile().getName(), () -> {                store.removeAll(new IdStartWithFilter(event.getFile().getPath()));                if (event.getFile().getLength() > 0) {                    documentIndexingPipeline.addDocument(event.getFile().getPath());                    currentModifiedFiles.remove(event.getFile().getPath());                }            });        }    }    private void handleFileDeleted(@NotNull VirtualFileEvent event) {        store.removeAll(new IdStartWithFilter(event.getFile().getPath()));    }    public void load() {        if (indexationRegistry.indexationIsProcessing(project.getName())) {            return;        }        if (!indexationRegistry.isIndexed(project.getName())) {            documentIndexingPipeline.handleCorruption();            new InitEmbeddingStoreTask(project, indexationRegistry).queue();        }    }    @Override    public void dispose() {        connection.disconnect();        debouncer.shutdown();        VirtualFileManager.getInstance().removeVirtualFileListener(virtualFileListener);    }}