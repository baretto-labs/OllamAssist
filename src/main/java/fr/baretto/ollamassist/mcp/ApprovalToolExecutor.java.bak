package fr.baretto.ollamassist.mcp;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.intellij.openapi.project.Project;
import dev.langchain4j.agent.tool.ToolExecutionRequest;
import dev.langchain4j.invocation.InvocationContext;
import dev.langchain4j.service.tool.ToolExecutionResult;
import dev.langchain4j.service.tool.ToolExecutor;
import fr.baretto.ollamassist.events.StopStreamingNotifier;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;

import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * ToolExecutor wrapper that requests user approval before executing MCP tools.
 * This executor intercepts tool execution requests and shows an approval dialog to the user.
 * If approved, it delegates to the underlying executor. If denied, it returns a cancellation message.
 */
@Slf4j
public class ApprovalToolExecutor implements ToolExecutor {

    private static final long APPROVAL_TIMEOUT_SECONDS = 300; // 5 minutes
    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    private final ToolExecutor delegate;
    private final McpApprovalService approvalService;
    private final Project project;

    /**
     * Create a new ApprovalToolExecutor.
     *
     * @param delegate The underlying executor to delegate to if approved
     * @param approvalService The service to request user approval
     * @param project The IntelliJ project (for message bus access)
     */
    public ApprovalToolExecutor(@NotNull ToolExecutor delegate,
                                @NotNull McpApprovalService approvalService,
                                @NotNull Project project) {
        this.delegate = delegate;
        this.approvalService = approvalService;
        this.project = project;
    }

    @Override
    public ToolExecutionResult executeWithContext(ToolExecutionRequest executionRequest,
                                                   InvocationContext invocationContext) {
        String toolName = executionRequest.name();
        String arguments = executionRequest.arguments();

        log.debug("Requesting approval for tool execution: {} with arguments: {}", toolName, arguments);

        try {
            // Request approval from user
            CompletableFuture<Boolean> approvalFuture = approvalService.requestApproval(toolName, arguments);

            // Wait for approval with timeout
            Boolean approved = approvalFuture.get(APPROVAL_TIMEOUT_SECONDS, TimeUnit.SECONDS);

            if (approved != null && approved) {
                log.info("Tool execution approved by user: {}", toolName);
                // Execute the tool using the delegate
                return delegate.executeWithContext(executionRequest, invocationContext);
            } else {
                log.info("Tool execution denied by user: {}", toolName);
                // Stop LLM streaming
                stopStreaming();
                return ToolExecutionResult.success("Tool execution was cancelled by the user");
            }

        } catch (TimeoutException e) {
            log.warn("Approval request timed out for tool: {}", toolName, e);
            stopStreaming();
            return ToolExecutionResult.success("Tool execution request timed out waiting for user approval");

        } catch (InterruptedException e) {
            log.warn("Approval request was interrupted for tool: {}", toolName, e);
            Thread.currentThread().interrupt(); // Restore interrupt status
            stopStreaming();
            return ToolExecutionResult.success("Tool execution request was interrupted");

        } catch (ExecutionException e) {
            log.error("Error during approval request for tool: {}", toolName, e);
            stopStreaming();
            return ToolExecutionResult.success("Error requesting approval: " + e.getMessage());

        } catch (Exception e) {
            log.error("Error executing tool: {}", toolName, e);
            return ToolExecutionResult.success("Error executing tool: " + e.getMessage());
        }
    }

    /**
     * Stop the LLM streaming by publishing a stop notification.
     */
    private void stopStreaming() {
        try {
            project.getMessageBus()
                    .syncPublisher(StopStreamingNotifier.TOPIC)
                    .stopStreaming();
            log.debug("Published stop streaming notification");
        } catch (Exception e) {
            log.error("Failed to publish stop streaming notification", e);
        }
    }

    /**
     * Parse JSON arguments into a human-readable format.
     * Converts JSON object to key-value pairs, one per line.
     *
     * @param arguments The JSON arguments string
     * @return Formatted string with one parameter per line, or empty string if null/empty
     */
    public static String parseArguments(String arguments) {
        if (arguments == null || arguments.trim().isEmpty()) {
            return "";
        }

        try {
            // Try to parse as JSON
            @SuppressWarnings("unchecked")
            Map<String, Object> argsMap = OBJECT_MAPPER.readValue(arguments, Map.class);

            // Build formatted output
            StringBuilder formatted = new StringBuilder();
            argsMap.forEach((key, value) -> {
                if (formatted.length() > 0) {
                    formatted.append("\n");
                }
                formatted.append(key).append(": ").append(formatValue(value));
            });

            return formatted.toString();
        } catch (Exception e) {
            log.debug("Failed to parse arguments as JSON, returning original string", e);
            return arguments;
        }
    }

    /**
     * Format a value for display (handles nested objects and arrays).
     */
    private static String formatValue(Object value) {
        if (value == null) {
            return "null";
        }

        if (value instanceof Map) {
            @SuppressWarnings("unchecked")
            Map<String, Object> map = (Map<String, Object>) value;
            StringBuilder sb = new StringBuilder();
            map.forEach((k, v) -> {
                if (sb.length() > 0) {
                    sb.append(", ");
                }
                sb.append(k).append(": ").append(formatValue(v));
            });
            return sb.toString();
        }

        if (value instanceof Iterable) {
            StringBuilder sb = new StringBuilder("[");
            boolean first = true;
            for (Object item : (Iterable<?>) value) {
                if (!first) {
                    sb.append(", ");
                }
                sb.append(formatValue(item));
                first = false;
            }
            sb.append("]");
            return sb.toString();
        }

        return value.toString();
    }
}
